/*
   SHA units 
*/
module ShaSingleState(in){
   Reg reg;
#
   a = reg + in;
   a -> reg;
   reg -> out;
}

// Unit that saves SHA state
module ShaState(x[8]){
   ShaSingleState s[8];
#
   x[0..7] -> s[0..7];
   s[0..7] -> out:0..7;
}

// All the memories can share configuration since they all output the same amount of data
module Constants(){
   static OnlyOutputMem mem;
#
   mem -> out:0;
}

// SHA is basically a loop that changes state per run based on data read from memory.
module SHA(){
   VRead MemRead;
   SwapEndian Swap; // Need to swap endianess to work properly. 
   xunitF F0;
   xunitF F1;
   xunitF F2;
   xunitF F3;
   xunitM M0;
   xunitM M1;
   xunitM M2;
   Constants cMem0; // Constants required by the algorithm
   Constants cMem1;
   Constants cMem2;
   Constants cMem3;
   ShaState State;  // We save the state internally since we need it every run and the software only cares about the final state. 
#
   MemRead -> Swap;
   
   {State:0..7,cMem0,Swap} -> F0:0..9;
   {F0:0..7   ,cMem1,M0}   -> F1:0..9;
   {F1:0..7   ,cMem2,M1}   -> F2:0..9;
   {F2:0..7   ,cMem3,M2}   -> F3:0..9;

   Swap -> M0;
   M0 -> M1;
   M1 -> M2;
   
   F3:0..7 -> State:0..7;
}

/*
   AES units
*/

// AES needs to apply a SBox transformation to each one of the 16 bytes being processed.
// We group them in a module to be easier to configure in software
module SBoxGroup(x[16]){
   SBox box[16];
#
   x[0..15] -> box[0..15];
   box[0..15] -> out:0..15;
}

// Reverse boxes
module RSBoxGroup(x[16]){
   RSBox box[16];
#
   x[0..15] -> box[0..15];
   box[0..15] -> out:0..15;
}


module ShiftRows(x[16]){
#
   // First row
   {x[0],x[4],x[8],x[12]} -> {out:0,out:4,out:8,out:12};

   // Second row
   {x[1],x[5],x[9],x[13]} -> {out:13,out:1,out:5,out:9};

   // Third row
   {x[2],x[6],x[10],x[14]} -> {out:10,out:14,out:2,out:6};

   // Fourth row
   {x[3],x[7],x[11],x[15]} -> {out:7,out:11,out:15,out:3};
}

module InvShiftRows(x[16]){
#
   // First row
   {x[0],x[4],x[8],x[12]} -> {out:0,out:4,out:8,out:12};

   // Second row
   {x[1],x[5],x[9],x[13]} -> {out:5,out:9,out:13,out:1};

   // Third row
   {x[2],x[6],x[10],x[14]} -> {out:10,out:14,out:2,out:6};

   // Fourth row
   {x[3],x[7],x[11],x[15]} -> {out:15,out:3,out:7,out:11};
}

module InvDoRow(x[4]){
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul9[2]; // We do need to change address sizes otherwise the default value from Versat would exhaust all the memory available.
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul11[2];
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul13[2];
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul14[2];
#
   // "Multiple" (lookup) each by 9,11,13,14
   x[0..3] -> { mul9[0]:0..1, mul9[1]:0..1};
   x[0..3] -> {mul11[0]:0..1,mul11[1]:0..1};
   x[0..3] -> {mul13[0]:0..1,mul13[1]:0..1};
   x[0..3] -> {mul14[0]:0..1,mul14[1]:0..1};

   r0 = mul14[0] ^ mul11[0]:1 ^ mul13[1] ^  mul9[1]:1;
   r1 =  mul9[0] ^ mul14[0]:1 ^ mul11[1] ^ mul13[1]:1;
   r2 = mul13[0] ^  mul9[0]:1 ^ mul14[1] ^ mul11[1]:1;
   r3 = mul11[0] ^ mul13[0]:1 ^  mul9[1] ^ mul14[1]:1;

   {r0,r1,r2,r3} -> out:0..3;
}

module DoRow(x[4]){
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul2[2];
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul3[2];
#
   // "Multiple" (lookup) each by 2 and by 3
   x[0..3] -> {mul2[0]:0..1,mul2[1]:0..1};
   x[0..3] -> {mul3[0]:0..1,mul3[1]:0..1};

   r0 = x[2] ^ x[3] ^ mul2[0]   ^ mul3[0]:1;
   r1 = x[0] ^ x[3] ^ mul2[0]:1 ^ mul3[1] ;
   r2 = x[0] ^ x[1] ^ mul2[1]   ^ mul3[1]:1;
   r3 = x[1] ^ x[2] ^ mul2[1]:1 ^ mul3[0];

   {r0,r1,r2,r3} -> out:0..3;
}

module MixColumns(x[16]){
   DoRow d[4];
#
   {x[0],x[1],x[2],x[3]}  -> d[0]:0..3;
   {x[4],x[5],x[6],x[7]}  -> d[1]:0..3;
   {x[8],x[9],x[10],x[11]} -> d[2]:0..3;
   {x[12],x[13],x[14],x[15]} -> d[3]:0..3;

   d[0]:0..3 -> {out:0,out:1,out:2,out:3};
   d[1]:0..3 -> {out:4,out:5,out:6,out:7};
   d[2]:0..3 -> {out:8,out:9,out:10,out:11};
   d[3]:0..3 -> {out:12,out:13,out:14,out:15};
}

module InvMixColumns(x[16]){
   InvDoRow d[4];
#
   {x[0],x[1],x[2],x[3]}  -> d[0]:0..3;
   {x[4],x[5],x[6],x[7]}  -> d[1]:0..3;
   {x[8],x[9],x[10],x[11]} -> d[2]:0..3;
   {x[12],x[13],x[14],x[15]} -> d[3]:0..3;

   d[0]:0..3 -> {out:0,out:1,out:2,out:3};
   d[1]:0..3 -> {out:4,out:5,out:6,out:7};
   d[2]:0..3 -> {out:8,out:9,out:10,out:11};
   d[3]:0..3 -> {out:12,out:13,out:14,out:15};
}

module XorAdd(x[16],y[16]){
#
   a[0] = x[0] ^ y[0];
   a[1] = x[1] ^ y[1];
   a[2] = x[2] ^ y[2];
   a[3] = x[3] ^ y[3];
   a[4] = x[4] ^ y[4];
   a[5] = x[5] ^ y[5];
   a[6] = x[6] ^ y[6];
   a[7] = x[7] ^ y[7];
   a[8] = x[8] ^ y[8];
   a[9] = x[9] ^ y[9];
   a[10] = x[10] ^ y[10];
   a[11] = x[11] ^ y[11];
   a[12] = x[12] ^ y[12];
   a[13] = x[13] ^ y[13];
   a[14] = x[14] ^ y[14];
   a[15] = x[15] ^ y[15];

   a[0..15] -> out:0..15;
}

// Next key generation logic that supports 128 bit and 256 bit AES
module GenericLineKey(x[4],w[4],rcon){
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) b[2];
   Mux2 mux[4];
#
   {x[0],x[1],x[2],x[3]} -> mux[0..3]:0; // Fourth line 
   {x[1],x[2],x[3],x[0]} -> mux[0..3]:1; // First line

   mux[0..3] -> {b[0]:0..1,b[1]:0..1};

   d[0] = b[0]:0 ^ w[0] ^ rcon;
   d[1] = b[0]:1 ^ w[1];
   d[2] = b[1]:0 ^ w[2];
   d[3] = b[1]:1 ^ w[3];

   d[0..3] -> out:0..3;
}

module GenericKeySchedule256(x[16],w[16],rcon){
   GenericLineKey s;
#
   {x[12],x[13],x[14],x[15]} -> s:0..3;
   {w[0],w[1],w[2],w[3]}     -> s:4..7;
   rcon -> s:8;

   a[0] = s:0 ^ w[4];
   a[1] = s:1 ^ w[5];
   a[2] = s:2 ^ w[6];
   a[3] = s:3 ^ w[7];

   b[0] = a[0] ^ w[8];
   b[1] = a[1] ^ w[9];
   b[2] = a[2] ^ w[10];
   b[3] = a[3] ^ w[11];

   c[0] = b[0] ^ w[12];
   c[1] = b[1] ^ w[13];
   c[2] = b[2] ^ w[14];
   c[3] = b[3] ^ w[15];

   s:0..3  -> out:0..3;
   a[0..3] -> out:4..7;
   b[0..3] -> out:8..11;
   c[0..3] -> out:12..15;
}

// All the AES dapath described using the same format.
module AESFirstAdd(x[16],k[16],iv[16]){
   XorAdd addKey;
   XorAdd addKey2;
#
   x[0..15] -> addKey:0..15;
   k[0..15] -> addKey:16..31;

   addKey:0..15 -> addKey2:0..15;
   iv[0..15]    -> addKey2:16..31;

   addKey2:0..15 -> out:0..15;
}

module AESInvFirstAdd(x[16],k[16],iv[16]){
   XorAdd addKey;
#
   x[0..15] -> addKey:0..15;
   k[0..15] -> addKey:16..31;

   addKey:0..15 -> out:0..15;
}

module AESRound(x[16],k[16],iv[16]){
   SBoxGroup subBytes;
   ShiftRows shiftRows;
   MixColumns mixColumns;
   XorAdd addKey;
#   
   x[0..15] -> subBytes:0..15;
   subBytes:0..15 -> shiftRows:0..15;
   shiftRows:0..15 -> mixColumns:0..15;
   mixColumns:0..15 -> addKey:0..15;
   k[0..15] -> addKey:16..31;

   addKey:0..15 -> out:0..15;
}

module AESInvRound(x[16],k[16],iv[16]){
   InvShiftRows invShiftRows;
   RSBoxGroup subBytes;
   XorAdd addKey;
   InvMixColumns invMixColumns;
#
   x[0..15] -> invShiftRows:0..15;
   invShiftRows:0..15 -> subBytes:0..15;
   subBytes:0..15 -> addKey:0..15;
   k[0..15] -> addKey:16..31;

   addKey:0..15 -> invMixColumns:0..15;

   invMixColumns:0..15 -> out:0..15;
}

module AESLastRound(x[16],key[16],iv[16]){
   SBoxGroup subBytes;
   ShiftRows shiftRows;
   XorAdd addKeyGood;
#
   x[0..15] -> subBytes:0..15;
   subBytes:0..15 -> shiftRows:0..15;
   shiftRows:0..15 -> addKeyGood:0..15;

   key[0..15] -> addKeyGood:16..31; 

   addKeyGood:0..15 -> out:0..15;
}

module AESInvLastRound(x[16],key[16],iv[16]){
   InvShiftRows invShiftRows;
   RSBoxGroup subBytes;
   XorAdd addKey;
   XorAdd removeIv;
#
   x[0..15] -> invShiftRows:0..15;
   invShiftRows:0..15 -> subBytes:0..15;

   subBytes:0..15 -> addKey:0..15;
   key[0..15]     -> addKey:16..31; 

   addKey:0..15 -> removeIv:0..15;
   iv[0..15]    -> removeIv:16..31;

   removeIv:0..15 -> out:0..15;
}

// We describe all the AES datapath that can change by this module 
merge FullAESRounds = AESFirstAdd | AESRound | AESLastRound | AESInvFirstAdd | AESInvRound | AESInvLastRound;

// This module only cares about describing the state and units that guard state and memories.
// The entire "datapath" is basically the FullAESRounds units.
module FullAES(){
   share config RegFile{
      key[16];
   }
   share config Reg{
      state[16];
   }
   share config Reg{
      lastResult[16]; // Used to support CBC mode
   }
   share config Reg{
      lastValToAdd[16]; // Used to support CTR mode
   }

   GenericKeySchedule256 schedule;
   Const rcon;
   FullAESRounds round;
   XorAdd lastAdd;
#
   key[0..15]:1 -> schedule:0..15;
   key[0..15]:0 -> schedule:16..31;
   rcon         -> schedule:32;

   schedule:0..15 -> key[0..15];

   state[0..15] -> round:0..15;
   key[0..15]   -> round:16..31;
   lastResult[0..15] -> round:32..47;

   round:0..15 -> lastAdd:0..15;
   lastValToAdd[0..15] -> lastAdd:16..31;

   lastAdd:0..15 -> state[0..15];
   lastAdd:0..15 -> lastResult[0..15];
}

// The entire McEliece unit is basically just a glorified SIMD processor.
// Store current row in mat, use VRead to read the rows needed to process and 
// either we use row to change mat or we use mat to change row and write back to mem.
// It is currently only used to speed up Gaussian elimination
module McEliece(){
   ReadWriteMem mat;
   VRead row;
   VWrite writer;
   Const mask;
#
   a = row & mask;
   b = mat ^ a;

   c = mat & mask;
   d = row ^ c;

   b -> mat;
   d -> writer;
}

module CryptoAlgos(){
   FullAES aes;
   SHA sha;
   McEliece eliece;
#
}
