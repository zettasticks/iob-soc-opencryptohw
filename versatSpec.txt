/*
   SHA units 
*/
module ShaSingleState(in){
   Reg reg;
#
   a = reg + in;
   a -> reg;
   reg -> out;
}

// Simple grouping of state so it appears better on the graphs
module ShaState(x[8]){
   ShaSingleState s[8];
#
   x[0..7] -> s[0..7];
   s[0..7] -> out:0..7;
}

module Constants(){
   static OnlyOutputMem mem;
#
   mem -> out:0;
}

module SHA(){
   VRead MemRead;
   SwapEndian Swap; // Need to swap endianess to work properly
   xunitF F0;
   xunitF F1;
   xunitF F2;
   xunitF F3;
   xunitM M0;
   xunitM M1;
   xunitM M2;
   Constants cMem0; // Constants required by the algorithm
   Constants cMem1;
   Constants cMem2;
   Constants cMem3;
   ShaState State;  // Saves the state internally. 
#
   MemRead -> Swap;
   
   {State:0..7,cMem0,Swap} -> F0:0..9;
   {F0:0..7   ,cMem1,M0}   -> F1:0..9;
   {F1:0..7   ,cMem2,M1}   -> F2:0..9;
   {F2:0..7   ,cMem3,M2}   -> F3:0..9;

   Swap -> M0;
   M0 -> M1;
   M1 -> M2;
   
   F3:0..7 -> State:0..7;
}

/*
   AES units
*/

module SBoxGroup(x[16]){
   SBox box[16];
#
   x[0..15] -> box[0..15];
   box[0..15] -> out:0..15;
}

module RSBoxGroup(x[16]){
   RSBox box[16];
#
   x[0..15] -> box[0..15];
   box[0..15] -> out:0..15;
}

module ShiftRows(x[16]){
#
   // First row
   {x[0],x[4],x[8],x[12]} -> {out:0,out:4,out:8,out:12};

   // Second row
   {x[1],x[5],x[9],x[13]} -> {out:13,out:1,out:5,out:9};

   // Third row
   {x[2],x[6],x[10],x[14]} -> {out:10,out:14,out:2,out:6};

   // Fourth row
   {x[3],x[7],x[11],x[15]} -> {out:7,out:11,out:15,out:3};
}

module InvShiftRows(x[16]){
#
   // First row
   {x[0],x[4],x[8],x[12]} -> {out:0,out:4,out:8,out:12};

   // Second row
   {x[1],x[5],x[9],x[13]} -> {out:5,out:9,out:13,out:1};

   // Third row
   {x[2],x[6],x[10],x[14]} -> {out:10,out:14,out:2,out:6};

   // Fourth row
   {x[3],x[7],x[11],x[15]} -> {out:15,out:3,out:7,out:11};
}

module InvDoRow(x[4]){
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul9[2];
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul11[2];
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul13[2];
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul14[2];
#
   // "Multiple" (lookup) each by 9,11,13,14
   x[0..3] -> { mul9[0]:0..1, mul9[1]:0..1};
   x[0..3] -> {mul11[0]:0..1,mul11[1]:0..1};
   x[0..3] -> {mul13[0]:0..1,mul13[1]:0..1};
   x[0..3] -> {mul14[0]:0..1,mul14[1]:0..1};

   r0 = mul14[0] ^ mul11[0]:1 ^ mul13[1] ^  mul9[1]:1;
   r1 =  mul9[0] ^ mul14[0]:1 ^ mul11[1] ^ mul13[1]:1;
   r2 = mul13[0] ^  mul9[0]:1 ^ mul14[1] ^ mul11[1]:1;
   r3 = mul11[0] ^ mul13[0]:1 ^  mul9[1] ^ mul14[1]:1;

   {r0,r1,r2,r3} -> out:0..3;
}

module DoRow(x[4]){
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul2[2];
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul3[2];
#
   // "Multiple" (lookup) each by 2 and by 3
   x[0..3] -> {mul2[0]:0..1,mul2[1]:0..1};
   x[0..3] -> {mul3[0]:0..1,mul3[1]:0..1};

   r0 = x[2] ^ x[3] ^ mul2[0]   ^ mul3[0]:1;
   r1 = x[0] ^ x[3] ^ mul2[0]:1 ^ mul3[1] ;
   r2 = x[0] ^ x[1] ^ mul2[1]   ^ mul3[1]:1;
   r3 = x[1] ^ x[2] ^ mul2[1]:1 ^ mul3[0];

   {r0,r1,r2,r3} -> out:0..3;
}

module MixColumns(x[16]){
   DoRow d[4];
#
   {x[0],x[1],x[2],x[3]}  -> d[0]:0..3;
   {x[4],x[5],x[6],x[7]}  -> d[1]:0..3;
   {x[8],x[9],x[10],x[11]} -> d[2]:0..3;
   {x[12],x[13],x[14],x[15]} -> d[3]:0..3;

   d[0]:0..3 -> {out:0,out:1,out:2,out:3};
   d[1]:0..3 -> {out:4,out:5,out:6,out:7};
   d[2]:0..3 -> {out:8,out:9,out:10,out:11};
   d[3]:0..3 -> {out:12,out:13,out:14,out:15};
}

module InvMixColumns(x[16]){
   InvDoRow d[4];
#
   {x[0],x[1],x[2],x[3]}  -> d[0]:0..3;
   {x[4],x[5],x[6],x[7]}  -> d[1]:0..3;
   {x[8],x[9],x[10],x[11]} -> d[2]:0..3;
   {x[12],x[13],x[14],x[15]} -> d[3]:0..3;

   d[0]:0..3 -> {out:0,out:1,out:2,out:3};
   d[1]:0..3 -> {out:4,out:5,out:6,out:7};
   d[2]:0..3 -> {out:8,out:9,out:10,out:11};
   d[3]:0..3 -> {out:12,out:13,out:14,out:15};
}

module XorAdd(x[16],y[16]){
#
   a[0] = x[0] ^ y[0];
   a[1] = x[1] ^ y[1];
   a[2] = x[2] ^ y[2];
   a[3] = x[3] ^ y[3];
   a[4] = x[4] ^ y[4];
   a[5] = x[5] ^ y[5];
   a[6] = x[6] ^ y[6];
   a[7] = x[7] ^ y[7];
   a[8] = x[8] ^ y[8];
   a[9] = x[9] ^ y[9];
   a[10] = x[10] ^ y[10];
   a[11] = x[11] ^ y[11];
   a[12] = x[12] ^ y[12];
   a[13] = x[13] ^ y[13];
   a[14] = x[14] ^ y[14];
   a[15] = x[15] ^ y[15];

   a[0..15] -> out:0..15;
}

/*
module FirstLineKey(x[4],w[4],rcon){
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) b[2];
#
   {x[1],x[2],x[3],x[0]} -> {b[0]:0..1,b[1]:0..1};

   d[0] = b[0]:0 ^ w[0] ^ rcon;
   d[1] = b[0]:1 ^ w[1];
   d[2] = b[1]:0 ^ w[2];
   d[3] = b[1]:1 ^ w[3];

   d[0..3] -> out:0..3;
}

module FourthLineKey(x[4],w[4]){
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) b[2];
#
   {x[0..1],x[2..3]} -> {b[0]:0..1,b[1]:0..1};

   d[0] = b[0]:0 ^ w[0];
   d[1] = b[0]:1 ^ w[1];
   d[2] = b[1]:0 ^ w[2];
   d[3] = b[1]:1 ^ w[3];

   d[0..3] -> out:0..3; 
}

module KeySchedule(x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,xa,xb,xc,xd,xe,xf,rcon){
   FirstLineKey s;
#
   x3 -> s:0;
   x7 -> s:1;
   xb -> s:2;
   xf -> s:3;
   x0 -> s:4;
   x4 -> s:5;
   x8 -> s:6;
   xc -> s:7;
   rcon -> s:8;

   a0 = s:0 ^ x1;
   a1 = s:1 ^ x5;
   a2 = s:2 ^ x9;
   a3 = s:3 ^ xd;

   b0 = a0 ^ x2;
   b1 = a1 ^ x6;
   b2 = a2 ^ xa;
   b3 = a3 ^ xe;

   c0 = b0 ^ x3;
   c1 = b1 ^ x7;
   c2 = b2 ^ xb;
   c3 = b3 ^ xf;

   s:0 -> out:0;
   s:1 -> out:4;
   s:2 -> out:8;
   s:3 -> out:12;
   a0 -> out:1;
   a1 -> out:5;
   a2 -> out:9;
   a3 -> out:13;
   b0 -> out:2;
   b1 -> out:6;
   b2 -> out:10;
   b3 -> out:14;
   c0 -> out:3;
   c1 -> out:7;
   c2 -> out:11;
   c3 -> out:15;
}

module KeySchedule256(x[32],rcon){
   FirstLineKey s;
   FourthLineKey q;
#
   {x[19],x[23],x[27],x[31]} -> s:0..3;
   {x[0],x[4],x[8],x[12]}    -> s:4..7;
   rcon -> s:8;

   a[0] = s:0 ^ x[1];
   a[1] = s:1 ^ x[5];
   a[2] = s:2 ^ x[9];
   a[3] = s:3 ^ x[13];

   b[0] = a[0] ^ x[2];
   b[1] = a[1] ^ x[6];
   b[2] = a[2] ^ x[10];
   b[3] = a[3] ^ x[14];

   c[0] = b[0] ^ x[3];
   c[1] = b[1] ^ x[7];
   c[2] = b[2] ^ x[11];
   c[3] = b[3] ^ x[15];

   c[0..3] -> q:0..3;

   {x[16],x[20],x[24],x[28]} -> q:4..7;

   d[0] = q:0 ^ x[17];
   d[1] = q:1 ^ x[21];
   d[2] = q:2 ^ x[25];
   d[3] = q:3 ^ x[29];

   e[0] = d[0] ^ x[18];
   e[1] = d[1] ^ x[22];
   e[2] = d[2] ^ x[26];
   e[3] = d[3] ^ x[30];

   f[0] = e[0] ^ x[19];
   f[1] = e[1] ^ x[23];
   f[2] = e[2] ^ x[27];
   f[3] = e[3] ^ x[31];

   s:0..3  -> {out:0,out:4,out:8,out:12};
   a[0..3] -> {out:1,out:5,out:9,out:13};
   b[0..3] -> {out:2,out:6,out:10,out:14};
   c[0..3] -> {out:3,out:7,out:11,out:15};

   q:0..3  -> {out:16,out:20,out:24,out:28};
   d[0..3] -> {out:17,out:21,out:25,out:29};
   e[0..3] -> {out:18,out:22,out:26,out:30};
   f[0..3] -> {out:19,out:23,out:27,out:31};
}
*/

module GenericLineKey(x[4],w[4],rcon){
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) b[2];
   Mux2 mux[4];
#
   {x[0],x[1],x[2],x[3]} -> mux[0..3]:0; // Fourth line 
   {x[1],x[2],x[3],x[0]} -> mux[0..3]:1; // First line

   mux[0..3] -> {b[0]:0..1,b[1]:0..1};

   d[0] = b[0]:0 ^ w[0] ^ rcon;
   d[1] = b[0]:1 ^ w[1];
   d[2] = b[1]:0 ^ w[2];
   d[3] = b[1]:1 ^ w[3];

   d[0..3] -> out:0..3;
}

module GenericKeySchedule256(x[16],w[16],rcon){
   GenericLineKey s;
#
   {x[12],x[13],x[14],x[15]} -> s:0..3;
   {w[0],w[1],w[2],w[3]}     -> s:4..7;
   rcon -> s:8;

   a[0] = s:0 ^ w[4];
   a[1] = s:1 ^ w[5];
   a[2] = s:2 ^ w[6];
   a[3] = s:3 ^ w[7];

   b[0] = a[0] ^ w[8];
   b[1] = a[1] ^ w[9];
   b[2] = a[2] ^ w[10];
   b[3] = a[3] ^ w[11];

   c[0] = b[0] ^ w[12];
   c[1] = b[1] ^ w[13];
   c[2] = b[2] ^ w[14];
   c[3] = b[3] ^ w[15];

   s:0..3  -> out:0..3;
   a[0..3] -> out:4..7;
   b[0..3] -> out:8..11;
   c[0..3] -> out:12..15;
}

module AESFirstAdd(x[16],k[16],iv[16]){
   XorAdd addKey;
   XorAdd addKey2;
#
   x[0..15] -> addKey:0..15;
   k[0..15] -> addKey:16..31;

   addKey:0..15 -> addKey2:0..15;
   iv[0..15]    -> addKey2:16..31;

   addKey2:0..15 -> out:0..15;
}

module AESInvFirstAdd(x[16],k[16],iv[16]){
   XorAdd addKey;
#
   x[0..15] -> addKey:0..15;
   k[0..15] -> addKey:16..31;

   addKey:0..15 -> out:0..15;
}

module AESRound(x[16],k[16],iv[16]){
   SBoxGroup subBytes;
   ShiftRows shiftRows;
   MixColumns mixColumns;
   XorAdd addKey;
#   
   x[0..15] -> subBytes:0..15;
   subBytes:0..15 -> shiftRows:0..15;
   shiftRows:0..15 -> mixColumns:0..15;
   mixColumns:0..15 -> addKey:0..15;
   k[0..15] -> addKey:16..31;

   addKey:0..15 -> out:0..15;
}

module AESInvRound(x[16],k[16],iv[16]){
   InvShiftRows invShiftRows;
   RSBoxGroup subBytes;
   XorAdd addKey;
   InvMixColumns invMixColumns;
#
   x[0..15] -> invShiftRows:0..15;
   invShiftRows:0..15 -> subBytes:0..15;
   subBytes:0..15 -> addKey:0..15;
   k[0..15] -> addKey:16..31;

   addKey:0..15 -> invMixColumns:0..15;

   invMixColumns:0..15 -> out:0..15;
}

module AESLastRound(x[16],key[16],iv[16]){
   SBoxGroup subBytes;
   ShiftRows shiftRows;
   XorAdd addKeyGood;
#
   x[0..15] -> subBytes:0..15;
   subBytes:0..15 -> shiftRows:0..15;
   shiftRows:0..15 -> addKeyGood:0..15;

   key[0..15] -> addKeyGood:16..31; 

   addKeyGood:0..15 -> out:0..15;
}

module AESInvLastRound(x[16],key[16],iv[16]){
   InvShiftRows invShiftRows;
   RSBoxGroup subBytes;
   XorAdd addKey;
   XorAdd removeIv;
#
   x[0..15] -> invShiftRows:0..15;
   invShiftRows:0..15 -> subBytes:0..15;

   subBytes:0..15 -> addKey:0..15;
   key[0..15]     -> addKey:16..31; 

   addKey:0..15 -> removeIv:0..15;
   iv[0..15]    -> removeIv:16..31;

   removeIv:0..15 -> out:0..15;
}

merge FullAESRounds = AESFirstAdd | AESRound | AESLastRound | AESInvFirstAdd | AESInvRound | AESInvLastRound;

module FullAES(){
   share config RegFile{
      key[16];
   }
   share config Reg{
      state[16];
   }
   share config Reg{
      lastResult[16];
   }
   share config Reg{
      lastValToAdd[16];
   }

   GenericKeySchedule256 schedule;
   Const rcon;
   FullAESRounds round;
   XorAdd lastAdd;
#
   key[0..15]:1 -> schedule:0..15;
   key[0..15]:0 -> schedule:16..31;
   rcon         -> schedule:32;

   schedule:0..15 -> key[0..15];

   state[0..15] -> round:0..15;
   key[0..15]   -> round:16..31;
   lastResult[0..15] -> round:32..47;

   round:0..15 -> lastAdd:0..15;
   lastValToAdd[0..15] -> lastAdd:16..31;

   lastAdd:0..15 -> state[0..15];
   lastAdd:0..15 -> lastResult[0..15];
}

module McEliece(){
   ReadWriteMem mat;
   VRead row;
   VWrite writer;
   Const mask;
#
   a = row & mask;
   b = mat ^ a;

   c = mat & mask;
   d = row ^ c;

   b -> mat;
   d -> writer;
}

module CryptoAlgos(){
   FullAES aes;
   SHA sha;
   McEliece eliece;
#
}
