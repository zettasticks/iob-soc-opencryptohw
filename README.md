# iob-soc-opencryptohw

SoC to run SHA, AES and McEliece programs on a RISC-V processor, with or without
acceleration using the VERSAT2.0 Coarse Grained Reconfigurable Array as a
hardware accelerator.

# Setup
Clone the repository and the submodules with:
```
git clone --recursive git@github.com:IObundle/iob-soc-opencryptohw.git
```
or using the url:
```
git clone --recursive https://github.com/IObundle/iob-soc-opencryptohw.git
```

### Requirements

Opencryptohw uses Nix environments to simplify dependency management. User must install 
nix-shell and any of the commands present in the next sections will automatically download 
any dependency required by opencryptohw. The only exception is the Vivado and Quartus tools
which are required for the FPGA targets and are not available through nix. These must be installed
and configured by the user.

* * *
# PC Emulation
The iob-soc-opencryptohw system can build and run an environment for PC with:
```
make pc-emul
```

The program runs the cryptographic algorithms and compares to a Known Answer Tests (KAT).

The result of the tests can be checked manually from terminal

* * *

# RISCV Emulation
The iob-soc-opencryptohw system can be emulated using a verilog simulator like icarus 
with:
```Make
make clean
# Test with all supported simulators
make sim-test
# Test with a specific simulator
make sim-run SIMULATOR=icarus
make sim-run SIMULATOR=verilator
```

# FPGA Execution
The system can be tested on FPGA with:
```
make fpga-test
```

The results can be manually checked in the terminal.

### Requirements/Setup [CHANGE]

FPGA execution requires:
- Supported FPGA board
- Setup environment for FPGA execution
    - Add the executable paths and license servers in `$HOME/.bashrc`:
    ```
    export VIVADOPATH=/path/to/vivado
    ...
    export LM_LICENSE_FILE=port@licenseserver.myorg.com;lic_or_dat_file
    ```
    - Follow [IOb-soc's README](https://github.com/IObundle/iob-soc#readme) for
    more installation details.

# Versat implementation

Versat is a tool that generates custom made accelerators following the dataflow paradigm. The accelerator used is fully specified in a custom language on the file versatSpec.txt. While the majority of units used are either default Versat units or more complex units generated by Versat, we do make use of some custom units which can be found in hardware\src\units. This units are 

## SHA-256

SHA-256 is a hash algorithm that transforms a sequence of bits into a 256 bit sized hash value. SHA first starts by initializing a state with a predefined value and by dividing the input into blocks of equal size. The algorithm then loops and for each block of the input, it combines it with the current state to generate the new state, which is combined with the next block and so on until no more blocks are left. 

To speedup SHA-256, we design the accelerator to process one block per run. In software, this portion is fully controlled by the function versat_crypto_hashblocks_sha256 defined in versat_crypto.c. 

The accelerator stores the state inside it and contains some memories to store all the constants required by the SHA algorithm. The logic is implemented by instantiating the xunitF and xunitM custom units, which are written in Verilog and can be found in hardware\src\units. While we could use Versat to generate  

We make use of a VRead unit to load the input. By using this unit, we can process data while reading the next block, effectively hidding the read latency. Since we only need to read a block (64 bytes = 16 reads of 4 bytes at a time) and it takes around 67 cycles to process a block, the accelerator is pratically never waiting for memory and is always doing useful work.

The full implementation of SHA-256 as a one-shot function is called VersatSHA. This function expects the entire input to be passed as an argument. 

An implementation that allows data to be streamed is given by the collection of functions BeginSHA,ProcessSHA and EndSHA. This set of functions allow data to be processed in chucks instead of processing everything at once.

Both the one-shot function and the streaming function contain extra logic at the end of the processing. This logic pertains to the processing of the last blocks. Since SHA processes 64 bytes at a time, SHA employs a padding scheme to make sure that any amount of blocks can be easily processed. This scheme basically always inserts a final block that is composed mostly of zeros except the last bytes which contain information about the amount of bytes processed.

## AES

AES is a symmetric key cryptographic algorithm that performs encryption and decryption of blocks of data given a key of size 128, 196 or 256 bits, depending on the version being used. Our implementation is capable of handling 128 and 256 bit keys.

AES define the concept of rounds, which consist of a bunch of steps which are performed repeatedly. A full AES implementation is normally divided into two parts, the first parts is called KeyExpansion and is responsible for expanding the initial key. Key expansion only needs to be performed once per key used, since the result of a key expansion is always the same for the same key. 

While key expansion could be performed entirely on software, since it is a fraction of the runtime for large inputs, we still implement it on the accelerator. Fully described using Versat, the logic to generate the key is contained inside the FullAES module and the GenericKeySchedule256 module and its subunits. 

Function ExpandKey contains the code to expand a key. Differences exist between 128 bit or 256 bit keys, but basically we apply rounds 

The second parts is to encrypt/decrypt the input. AES is a block chipher, which divides the input into blocks of 16 bytes, performs multiple rounds and the resulting 16 bytes is the output of that run. While the algorithm is based on applying the same rounds multiple times, the last round is slightly different from the normal round. Also there exists a bit of simple pre-round logic that needs to be applied. Decrypt is the inverse of encryption: we need to perform the opposite steps of encryption. This means that we have 6 total different forms of a "round": 3 forms for the pre-round, normal round and final round of encryption and the equal amount for the inverse.

We accomplish this fully in Versat, by defining each round individually and then performing a merge of all the round types. The FullAES implementation instantiates this merged unit, called FullAESRounds, and in software we change between round types according to our needs. This means that we implement our algorithm at the level of a round: each accelerator run does one round and to process a block we need to perform 11 (15) accelerator runs for AES-128 (AES-256).

Because AES is a block chipher, to process inputs of variable size, we need to implement a block chipher mode. We actually implement ECB, CBC and CTR modes. These modes can be seen on versat_crypto.c. Some extra units are required to insert in the accelerator to implement this modes, like adding the concept of IV to the round units and storing the last value of a run inside the FullAES module.

The Encrypt and Decrypt functions can be found inside versat_crypto.c. Other than some logic related to the block chipher mode of operation, the software implementation basically only needs to select the correct key values to be used by the block chipher and to change the merged instances when needed.

A more throughly explanation of AES can be found in https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf

## McEliece

The McEliece algorithm is a asymmetric form of encryption designed for Key encapsulation mechanism (KEM). After profiling the full run of McEliece, runnning Generation, Encapsulation and Decapsulation, it was found that one portion of the Generation accounted for the majority of time spent and it was that portion that we decided to accelerate.

The part that took the majority of the time was a simple portion of the code, that performs gaussian elimination of a big bit matrix. We accelerate it by saving the current row being processed internally inside the accelerator and using VRead and VWrite units to load the other rows, process them with the current row and storing the result back into memory.

## Full implementation

The full and final module that was used to generate the accelerator is called CryptoAlgos and is just the instantiation of each of the modules discussed previously. 

## Tests

Each cryptographic algorithm is tested by comparing to a Known Answer Test (KAT). For AES, we test AES-256 in ECB mode. 